# JWT (Security)

У нас есть Аня и Петя. Аня является **владельцем** access и refresh токенов.

Петя (выступает в роли злоумышленника) получает доступ к access и refresh токену Ани. Затем Петя:

- **использует access token**: Петя получает доступ к системе, но у этого токена короткий период жизни и Петя не сможет пользоваться
этим токеном больше условных 5-15 минут. Аня пойдет получать новый access по refresh и получит
новую пару токенов (допустим, что в системе есть *ротация*, на текущий момент не важно - что это).
Токены, которыми владеет Петя - перестанут работать.
- **использует refresh token**. Тут ситуация снова разделяется на две и...

- **...есть привязка к device_id или другому идентификатору устройста**. Петя не проходит эту верификацию,
токены помечаются как *"скомпрометированные"*, все токены *инвалидируются* у Ани и Пети отключается доступ.
Аня перезаходит и работает дальше, а Петя имеет набор бесполезных токенов в руках.
- **...нет привязки к device_id**. Петя успешно получает получает новый access token и продолжает
пользоваться сервисом дальше. Аня идёт обменивать refresh на access, сервер видит старый refresh token,
который был *инвалидирован Петей* и считает токены "скомрометированными". Так же инвалидируются все токены,
Аня перезаходит и работает дальше. Петя...ну вы поняли.

Во всей этой ситуации есть один момент: спецификация OAuth2 **не требует** инвалидации ранее
выданных токенов (https://datatracker.ietf.org/doc/html/rfc6749#section-6), но это можно реализовать.
> The authorization server MAY revoke the old refresh token after issuing a new refresh token to the client.

Как видно из истории, основная защита это:
- Не дать злоумышленнику украсть токен изначально
- А если токены украли, то обнаружить и минимизировать ущерб.

Разумеется, защита очень сильно зависит от самого приложения и насколько даже временная
компрометация может навредить пользователю. Если в приложении для похудения это может быть не так критично,
то в банковской системе даже минутный доступ может повлечь серьёзный ущерб.

## Токены и стратегии защиты

### Access Token

- *Короткий TTL* (5-15 минут). Фактически - это и есть время,
на которое злоумышленник получает доступ к системе (если исключить условности).

### Refresh Token

- **Длинный TTL** (7-30 дней), использовать только для обновления access токена.
- **Инвалидация**: при выдаче нового access токена с ним выдётся и *новый refresh token*, а *старый инвалидируется*
- **Семейства токенов (family)**: связывать токены уникальным ключом, который в случае компрометации позволит
отозвать всё семейство по ключу.
- **Проверка revication по `jti`/`family`**. Токен может быть отозван по разным причинам.
- **Проверка переиспользования (reuse detection)**: если у вас включена инвалидация - проверяйте, что это
не повторная попытка получить access token (компрометация). В случае обнаружения - отзывайте всю семью.

### Общее

- Не логируйте токены в системе. Если очень надо - маскируйте значения.

## Хранение

Браузер:
- Refresh: **HttpOnly + Secure + SameSite=Strict/Lax** cookie.
- Access: **в памяти** (не `localstorage`)
- Всегда **HTTPS + HSTS**

## Защита `/refresh`

- **CSRF-защита** (cookie + `X-CSRF-Token`)
- **Rate limit**

