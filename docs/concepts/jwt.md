# JWT

**JWT (JSON Web Token)** - это токен, подтверждающий доступ в определенные ресурсы.

- Клиент вводил "логин" и "пароль"
- Сервер выдаёт токен
- Клиент (через frontend) прикладывает его каждому запросу
- Сервер при получении запроса проверяет токен

## Жизненный цикл

```
 +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+
```
> Взято из https://datatracker.ietf.org/doc/html/rfc6749#section-1.5


### Термины

- **клиент** - frontend приложение (как представитель пользователя)

### Логин

Клиент отправляет логин/пароль, сервер их проверяет и выдаёт:
- **access token** - короткоживущий токен (например, 5-15 минут),
который кладется в HTTP Header `Authorization: Bearer ...`
- **refresh token** - долгоживущий токен (например, 7-30 дней),
который хранится безопасно, используется только для получения
нового *access token*

### API запросы

Клиент шлёт `Authorization: Bearer <access_token>` с запросом на сервер:
- Сервер проверяет **подпись**, **срок** (`exp`), **issuer** (`iss`), **audience** (`aud`),
**revocation** (черный список)
- Извлекает полезные данные (например, `sub` как User ID и `roles` как роли пользователя)
и применяет авторизацию

### Обновление (refresh)

Когда *access token* истёк или вот-вот истечёт - клиент
отправляет *refresh token* на специальный API:
- Сервер проверяет *refresh token*
- Выдаёт **новый access token**

> Так же существует операция **ротации** (rotation): старый *refresh token* делается невалидным
и выдаётся новый *refresh token* вместе с новым *access token*

### Выход

Когда клиент выходит:
- помечаем *refresh token** (и семейство токенов, если используется family) как **revoked**
- опционально режем доступ по `jti`/`family`

> Это же принцип применяется и при "отзыве" токена: когда админ ограничивает доступ

### Истечение

Когда наступает истечение (`exp` < now), токен становится недействителен.
Сервер на любой запрос должен отвечать **401 Unauthorized**, а клиент делает refresh
или логин.

## FAQ

### Q: А зачем нам вообще нужны 2 токена? Почему не 1?

A: *access token* может утечь. Если даже ваш *access token* украли - он проживёт недолго.
Но чтобы каждую минуту не логиниться, нужен *refresh token*.
Он хранится аккуратно и используется редко.

### Q: А почему *refresh token* считается безопасным? Разве он не может утечь?

TODO

### Claims (метаданные токена)

- `sub` - идентификатор пользователя
- `exp` - срок действия (timestamp)
- `iat` - когда выдан (timestamp)
- `nbf` - начало работы токены (timestamp); задаётся для токенов с отложенным стартом
- `iss` - кто выдал
- `aud` - для кого выдал
- личные токены (`roles`, `permissions`, `scope`, `jti`)


